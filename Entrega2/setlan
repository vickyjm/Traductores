#!/usr/bin/env python

##########################################
# CI3715 Traductores e Interpretadores   #
# Entrega 2. Grupo 6                     #
# Maria Victoria Jorge 11-10495          #
# Enrique Iglesias 11-10477              # 
##########################################

import ply.lex as lex
import sys
import ply.yacc as yacc

# Palabras reservadas del lenguaje
reserved = {
    # Lenguaje
    'program' : 'Program',
    'using' : 'Using',
    'in' : 'In',

    # Condicionales
    'if' : 'IF',
    'else' : 'ELSE',

    # Ciclos
    'for' : 'FOR',
    'min' : 'MIN',
    'max' : 'MAX',
    'repeat' : 'REPEAT',
    'while' : 'WHILE',
    'do' : 'DO',

    # E/S
    'scan' : 'Scan',
    'print' : 'Print',
    'println' : 'Println',

    # Tipos
    'int' : 'Int',
    'bool' : 'Boolean',
    'set' : 'Set',

    # Operadores Logicos
    'and' : 'And',
    'or' : 'Or',
    'not' : 'Not',

    # Valores Booleanos
    'true' : 'True',
    'false' : 'False'
}

# Tokens que se pueden reconocer
tokens = [
    # Identificadores
    'ID',

    # Operadores de mapeo
    'PlusMap',
    'MinusMap',
    'TimesMap',
    'DivideMap',
    'ModuleMap',

    # Cadena de caracteres
    'String',

    # Operadores de conjuntos
    'Union',
    'Intersection',
    'Diference',
    'MinSet',
    'MaxSet',
    'Size',
    'At',

    # Operadores relacionales
    'Less',
    'Greater',
    'GreaterEqual',
    'LessEqual',
    'Equals',
    'NotEqual',

    # Lenguaje
    'Number',
    'Comma',
    'Assign',
    'Semicolon',
    'OpenCurly',
    'CloseCurly',
    'Rparen',
    'Lparen',

    # Operadores de enteros
    'Plus',
    'Minus',
    'Times',
    'Divide',
    'Module'
] + list(reserved.values())


def t_ID(t):
    r'[_A-Za-z]([_A-Za-z0-9])*'
    t.type = reserved.get(t.value,'ID')
    return t

t_PlusMap = r'<\+>'
t_MinusMap = r'<->'
t_TimesMap = r'<\*>'
t_DivideMap = r'</>'
t_ModuleMap = r'<%>'

def t_String(t):
    r'"([^"\\\n]|\\"|\\\\|\\n)*"'
    t.value = t.value[1:-1]
    return t

t_Union = r'\+\+'
t_Intersection = r'><'
t_Diference = r'\\'
t_MaxSet = r'>\?'
t_MinSet = r'<\?'
t_Size = r'\$\?'
t_At = r'@'
t_Less = r'>'
t_Greater = r'<'
t_GreaterEqual = r'>='
t_LessEqual = r'<='
t_Equals = r'=='
t_NotEqual = r'/='

# Retorna el valor de un numero usando el tipo int de Python
def t_Number(t):
    r'\d+'
    t.value = int(t.value)    
    return t

t_Comma = r','
t_Assign = r'='
t_Semicolon = r';'
t_OpenCurly = r'\{'
t_CloseCurly = r'\}'
t_Lparen = r'\('
t_Rparen  = r'\)'
t_Plus    = r'\+'
t_Minus   = r'-'
t_Times   = r'\*'
t_Divide  = r'/'
t_Module = r'%'


# Funcion para realizar un seguimiento de los numeros de linea. El unico caracter
# valido para el salto de linea es '\n'
def t_newline(t):
    r'\n+'
    t.lexer.lineno += len(t.value)
    
# Ignora tabs, espacios y comentarios (estilo Python)
t_ignore  = ' \t'
t_ignore_comments  = r'\#.*'

# Permite encontrar el numero de columna de la linea actual
def find_column(input,token):
    last_cr = input.rfind('\n',0,token.lexpos)
    if last_cr < 0:
        last_cr = -1
    column = token.lexpos - last_cr
    return column
        
# Manejo de errores en caso de encontrar un caracter invalido
def t_error(t):
    error.append(t)
    t.lexer.skip(1)

class Program:
    def __init__(self,inst):
        self.inst = inst

    def toString(self):
        return 'PROGRAM\n' + self.inst.toString(2)

class Bloque:
    def __init__(self,exp):
        self.exp = exp

    def toString(self,tabs):
        string = ' '*tabs + 'BLOCK_BEGIN\n'
        string += ' '*(tabs + 2) + self.exp.toString(tabs + 2) + '\n'
        string += ' '*tabs + 'BLOCK_END\n'
        return string

class Declarar:
    def __init__(self,var):
        self.var = var

    def toString(self,tabs):
        string = ' '*tabs + 'USING\n'
        string += ' '*(tabs + 2) + self.var.toString(tabs + 2) + '\n'
        string += ' '*tabs + 'IN\n'
        return string


class Condicional:
    def __init__(self, cond, inst, inst2):
        self.cond = cond
        self.inst = inst
        self.inst2 = inst2

    def toString(self,tabs):

class Asignacion:
    def __init__(self,var,valor):
        self.var = var
        self.valor = valor

    def toString(self,tabs):
        string = ' '*tabs + 'ASSIGN\n'
        string += ' '*(tabs + 2) + 'variable\n'
        string += ' '*(tabs + 4) + self.var + '\n'
        string += ' '*(tabs + 6) + self.valor.toString(tabs + 6) + '\n'
        return string

class For:
    def __init__(self, id1, direc, id2, inst):
        self.id1 = id1
        self.direc = direc
        self,id2 = id2
        self.inst = inst

class While:
    def __init__(self,exp,inst):
        self.exp = exp
        self.inst = inst

class EntradaSalida:
    def __init__(self,flag,exp):
        self.flag = flag
        self.exp = exp

    def toString(self,tabs):
        string = ' '*tabs + self.flag.upper() + '\n'
        if (self.flag=='scan'):
            string += ' '*(tabs + 2) + 'variable\n'
            string += ' '*(tabs + 4) + self.exp.toString(tabs + 4)
        else:
            string += ' '*(tabs + 2) 'elements\n'
            for elem in exp:
                string += ' '*(tabs + 4) + self.exp.toString(tabs + 4) + '\n'
        return string

class Opbin:
    def __init__(self,izq,op,der):
        self.izq = izq
        self.op = op
        self.der = der

    def toString(self,tabs):
        operadores = {
            '+'     : 'PLUS',
            '-'     : 'MINUS',
            '*'     : 'TIMES',
            '/'     : 'DIVIDE',
            '%'     : 'MODULE',
            '++'    : 'UNION',
            '><'    : 'INTERSECTION',
            '\\'    : 'DIFERENCE',
            '<+>'   : 'PLUS_MAP',
            '<->'   : 'MINUS_MAP',
            '<*>'   : 'TIMES_MAP',
            '</>'   : 'DIVIDE_MAP',
            '<%>'   : 'MODULE_MAP',
            '<'     : 'LESS',
            '<='    : 'LESS_EQUAL',
            '>'     : 'GREATER',
            '>='    : 'GREATER_EQUAL',
            '=='    : 'EQUALS',
            '/='    : 'NOT_EQUAL',
            '@'     : 'AT'
        }
        string = operadores[self.op] + '\n'
        string += ' '*(tabs + 2) + 'variable' + '\n'
        string += self.izq.toString(tabs + 4) + '\n'
        string += ' '*(tabs + 2) 'variable' + '\n'
        string += self.der.toString(tabs + 4) + '\n'
        return string

class Tipos:
    def __init__(self,tipo,valor):
        self.tipo = tipo
        self.valor = valor

    def toString(self,tabs):


class Repeat:
    def __init__(self,flag,inst1,exp,inst2):
        self.flag = flag
        self.inst1 = inst1
        self.exp = exp
        self.inst2 = inst2

    def toString(self,tabs):


class Uniop:
    def __init__(self,op,val):
        self.val = val
        self.op = op

    def toString(self,tabs):
        operadores = {
            '-'     : 'UMINUS',
            '<?'    : 'MIN_SET',
            '>?'    : 'MAX_SET',
            '$?'    : 'SIZE'
        }
        string = ' '*tabs + operadores[self.op] + '\n'
        string += ' '*(tabs + 2) + self.val.toString(tabs + 2) + '\n'
        return string


class CadenaString:
    def __init__(self,def):
        self.string = string

    def toString(self,tabs):


precedence = (
    ('nonassoc', 'UMINUS', 'MinSet', 'MaxSet', 'Size'),
    ('nonassoc', 'TimesMap','DivideMap','ModuleMap'),
    ('nonassoc','PlusMap','MinusMap'),
    ('left','Intersection'),
    ('left','Union','Diference'),
    ('left','Times','Divide','Module')
    ('left', 'Plus', 'Minus'),
    ('nonassoc','Greater','GreaterEqual', 'Less','LessEqual'),
    ('left','Equals','NotEqual'),
    ('nonassoc','At'))

def p_program(p):
    '''PROGRAM : Program INST'''
    p[0] = Program(p[1])

def p_tipos(p):
    ''' TIPOS   : Int 
                | Set 
                | Bool '''
    p[0] = p[1]

def p_enumList(p): # ['Hola',x,'chao']
    '''ENUM_LIST    : STRING_LIST
                    | EXP
                    | ENUM_LIST Comma ENUM_LIST'''
    if (len(p)==2):
        p[0] = p[1]
    else:
        p[0] = [p[1],p[3]] 

def p_StringList(p):
    '''STRING_LIST -> String Comma STRING_LIST
                    | String '''
    if (len(p)==3):
        p[0] = [CadenaString(p[1]),p[3]]
    else:
        p[0] = CadenaString(p[1])

def p_declarar(p):
    '''DECLARAR : Using DEC_LIST In
                | Epsilon'''
    if (len(p)==4):
        p[0] = Declarar([p[2]])


def p_decList(p):
    '''DEC_LIST   : TIPOS COMA_LIST Semicolon DEC_LIST
                  | TIPOS COMA_LIST Semicolon '''
    if (len(p)==4):
        p[0] = Tipos(p[1],p[2])
    else:
        p[0] = [Tipos(p[1],p[2]),p[4]]

def p_listInst(p):
    '''INST_LIST    : INST Semicolon LIST_INST
                    | INST Semicolon '''
    if (len(p)==3):
        p[0] = p[1]
    else:
        p[0] = [p[1],p[2]]

def p_comaList(p):
    '''COMA_LIST    : Id Comma COMA_LIST
                    | Id '''
    if (len(p)==2):
        p[0] = p[1]
    else:
        p[0] = [p[1],p[3]]

def p_exp(p):
    '''EXP  : Number
            | Id
            | OpenCurly NUMBER_LIST CloseCurly
            | Lparen EXP Rparen
            | Minus EXP
            | EXP Plus EXP
            | EXP Minus EXP
            | EXP Times EXP
            | EXP Divide EXP
            | EXP Module EXP
            | EXP PlusMap EXP
            | EXP MinusMap EXP
            | EXP TimesMap EXP
            | EXP DivideMap EXP
            | EXP ModuleMap EXP
            | MaxSet EXP
            | MinSet EXP
            | Size EXP
            | True
            | False 
            | EXP And EXP
            | EXP Or EXP
            | Not EXP
            | EXP Equals EXP
            | EXP Greater EXP
            | EXP GreaterEqual EXP
            | EXP Less EXP
            | EXP LessEqual EXP
            | EXP NotEqual EXP
            | EXP At EXP '''

    if (len(p)==2): #Aqui va number, id, true, false
        if type(p[1]) is int:
            tipo = 'int'
        elif type(p[1]) is str:
            tipo = 'id'
        else:
            tipo = 'bool'
        p[0] = Tipos(tipo,p[1])

    elif (len(p)==3): #Operadores unarios
        p[0] = Uniop(p[1],p[2])
    else: #Operadores binarios
        if (p[1]=='('): # Caso (EXP)
            p[0] = p[2]
        elif (p[1]=='{'):
            p[0] = Tipos('set',p[2])
        else:
            p[0] = Opbin(p[1],p[2],p[3])


def p_inst(p):
    '''INST : Id = EXP
            | { DECLARAR INST_LIST }
            | scan Id
            | print ENUM_LIST
            | println ENUM_LIST
            | if ( EXP ) INST else INST
            | if ( EXP ) INST
            | for Id DIRECCION Id do INST
            | repeat INST while EXP
            | repeat INST while EXP do INST
            | while EXP do INST'''

    if (len(p) == 4):
        p[0] = Asignacion(p[1],p[3])
    elif (len(p) == 3):
        p[0] = EntradaSalida(p[1],p[2])
    elif (len(p) == 5):
        if (p[1] == '{'):
            p[0] = [p[2],[p[3]]]
        elif(p[1] == 'repeat'):
            p[0] = Repeat(p[1],p[2],p[4],None)
        else:
            p[0] = While(p[2],p[4])
    elif (len(p) == 6):
        p[0] = Condicional(p[3],p[5],None)
    elif (len(p) == 7):
        if (p[1] == 'repeat'):
            p[0] = Repeat(p[1],p[2],p[4],p[6])
        else:
            p[0] = For(p[2],p[3],p[4],p[6])
    else:
        p[0] = Condicional(p[3],p[5],p[7])

def p_direccion(p):
    ''' DIRECCION : Min
                  | Max '''
    p[0] = p[1]

def p_numberList(p):
    '''NUMBER_LIST  : Number Comma NUMBERLIST
                    | Number
                    | Epsilon '''
    if (len(p)==2):
        p[0] = p[1]
    else:
        p[0] = [p[1],p[2]]

def p_error(p):
    if (p is not None):
        print 'Error de sintaxis. Se encontró el token "'+ p.value +'" en la línea '+ p.lineno +', columna '+ find_column(myfile.read(),p)

if __name__ == '__main__':

    # Variable global donde se almacenan los errores en caso de existir
    global error
    error = []
    tokList = []
    lexer = lex.lex()

    if (len(sys.argv) != 2):
        print "Error con los argumentos de entrada"
        sys.exit(1)

    myfile = open(sys.argv[1], "r")
    lexer.input(myfile.read())
    
    while True:
        tok = lexer.token()
        if not tok: break
        tokList.append(tok)

    if (len(error) != 0):
        for aux in error :
            print 'Error: Se encontro un caracter inesperado ' + str(aux.value[0]),
            print ' en la Linea ' + str(aux.lineno) +' ,Columna ',
            print str(find_column(lexer.lexdata,aux))
    else:
        parser = yacc.yacc()
        salida = parser.parse(myfile.read())
        salida.toString(0)
    myfile.close()