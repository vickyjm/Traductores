#!/usr/bin/env python2.7

import ply.lex as lex
import sys, traceback

reserved = {
             'program' : 'Program',
             'using' : 'Using',
             'in' : 'In',
             'if' : 'IF',
             'then' : 'THEN',
             'else' : 'ELSE',
             'for' : 'FOR',
             'min' : 'MIN',
             'max' : 'MAX',
             'do' : 'DO',
             'repeat' : 'REPEAT',
             'while' : 'WHILE',
             'scan' : 'Scan',
             'def' : 'Def',
             'print' : 'Print',
             'println' : 'Println',
             'return' : 'Return',
              'int' : 'Int',
              'bool' : 'Boolean',
              'set' : 'Set',
              'and' : 'And',
              'or' : 'Or',
              'not' : 'Not',
              'true' : 'True',
              'false' : 'False'
             }

tokens = [
            'ID',
            'Comma',
            'OpenCurly',
            'Semicolon',
            'Colon',
            'CloseCurly',
            'Equals',
            'String',
            'Less',
            'Greater',
            'GreaterEqual',
            'LessEqual',
            'Equivalence',
            'NotEqual',
            'Plus',
            'Minus',
            'Times',
            'Divide',
            'Module',
            'Diference',
            'Min',
            'Max',
            'Prom',
            'At',
            'Dollar',
            'Rparen',
            'Lparen',
            'Union',
            'Intersection',
            'Number',
            'PlusMap',
            'MinusMap',
            'TimesMap',
            'DivideMap',
            'ModuleMap',
            'Arrow'
] + list(reserved.values())

t_PlusMap = r'<\+>'
t_MinusMap = r'<->'
t_TimesMap = r'<\*>'
t_DivideMap = r'</>'
t_ModuleMap = r'<%>'
t_Union = r'\+\+'
t_Plus    = r'\+'
t_Arrow = r'->'
t_Minus   = r'-'
t_Times   = r'\*'
t_Equivalence = r'=='
t_NotEqual = r'/='
t_Equals = r'='
t_Divide  = r'/'
t_Module = r'%'
t_Diference = r'\\'
t_Intersection = r'><'
t_GreaterEqual = r'>='
t_LessEqual = r'<='
t_Max = r'>\?'
t_Min = r'<\?'
t_Greater = r'<'
t_Less = r'>'
t_Dollar = r'\$\?'
t_At = r'@'
t_Comma = r','
t_Semicolon = r';'
t_Colon = r':'
t_OpenCurly = r'\{'
t_CloseCurly = r'\}'
t_Lparen = r'\('
t_Rparen  = r'\)'
t_String = r'".*?"'

def t_Number(t):
    r'\d+'
    t.value = int(t.value)    
    return t

def t_newline(t):
    r'\n+'
    t.lexer.lineno += len(t.value)
    

def t_ID(t):
    r'[_A-Za-z]([_A-Za-z0-9])*'
    t.type = reserved.get(t.value,'ID')
    return t

t_ignore  = ' \t'
t_ignore_comments  = r'\#.*'

def find_column(input,token):
    last_cr = input.rfind('\n',0,token.lexpos)
    if last_cr < 0:
        last_cr = -1
    column = token.lexpos - last_cr
    return column
        

def t_error(t):
    error.append(t)
    t.lexer.skip(1)

if __name__ == '__main__':

    global error
    error = []
    tokList = []
    lexer = lex.lex()

    if (len(sys.argv) != 2):
        sys.exit(1)

    myfile = open(sys.argv[1], "r")
    lexer.input(myfile.read())
    
    while True:
        tok = lexer.token()
        if not tok: break
        tokList.append(tok)
    

    if len(error) != 0:
        for aux in error :
            print 'Error: Se encontro un caracter inesperado "' + str(aux.value) + '" en la Linea ' + str(aux.lineno) +' ,Columna ' + str(find_column(lexer.lexdata,aux))
    else:
        for aux in tokList:
            if (aux.type == 'ID') or (aux.type == 'String'):
                print 'Token' + str(aux.type) +': "' +str(aux.value)+'"(Linea ' + str(aux.lineno) +', Columna '+ str(find_column(lexer.lexdata,aux))+')'
            else:
                print 'Token'+str(aux.type)+'(Linea ' + str(aux.lineno) +', Columna '+ str(find_column(lexer.lexdata,aux))+')'
    myfile.close()